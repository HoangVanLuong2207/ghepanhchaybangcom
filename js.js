// DOM Elements for input fields
const profileCropX = document.getElementById('profileCropX');
const profileCropY = document.getElementById('profileCropY');
const profileCropW = document.getElementById('profileCropW');
const profileCropH = document.getElementById('profileCropH');

const combineColsInput = document.getElementById('combineCols');
const combineRowsInput = document.getElementById('combineRows'); // Corrected this line previously

// Profile Canvas for profile image
const profileCanvas = document.getElementById('profileCanvas');
const profileCtx = profileCanvas.getContext('2d');
let previewImage_profile = new Image();
let currentProfileImageOriginalWidth = 0; // Store original width for scaling
let currentProfileImageOriginalHeight = 0; // Store original height for scaling

let croppedProfileImage = null; // Store the cropped profile image object

const inputProfileImage = document.getElementById('inputProfileImage');
const croppedImagesContainer = document.getElementById('croppedImagesContainer');
const finalOutputCanvas = document.getElementById('finalOutputCanvas');
const finalOutputCtx = finalOutputCanvas.getContext('2d');

let allCroppedBatchImages = []; // Stores ALL successfully cropped Image objects (for combining)
let croppedFilesData = {}; // Stores {fileName: dataURL} for batch cropped images (for ZIP)

// --- GLOBAL CANVAS RENDER MAX WIDTH ---
const CANVAS_RENDER_MAX_WIDTH = 500; // Max pixels for canvas display (adjust as needed for typical desktop)


// --- Event Listeners for Canvas Interaction and Input Updates ---
function setupCanvasInteraction(canvas, ctx, image, inputX, inputY, inputW, inputH, originalWidth, originalHeight) {
    let dragging = false, startX_canvas = 0, startY_canvas = 0;

    // Scale factors should be calculated based on the canvas's current *drawing* dimensions
    // and the original image dimensions.
    let scaleFactorX = canvas.width / originalWidth;
    let scaleFactorY = canvas.height / originalHeight;

    // This function will be called initially and whenever inputs change
    const updateScaleFactorsAndRedraw = () => {
        // Recalculate scale factors in case canvas dimensions were externally changed (though they shouldn't be now)
        scaleFactorX = canvas.width / originalWidth;
        scaleFactorY = canvas.height / originalHeight;
        drawCurrentRect("green");
    };

    function canvasToOriginalCoords(x_canvas, y_canvas) {
        return {
            x: Math.round(x_canvas / scaleFactorX),
            y: Math.round(y_canvas / scaleFactorY)
        };
    }

    function originalToCanvasCoords(x_orig, y_orig, w_orig, h_orig) {
        return {
            x: Math.round(x_orig * scaleFactorX),
            y: Math.round(y_orig * scaleFactorY),
            w: Math.round(w_orig * scaleFactorX),
            h: Math.round(h_orig * scaleFactorY)
        };
    }

    function getCanvasCoordsFromEvent(e) {
        // Use offsetLeft/offsetTop of the canvas to get its position relative to the document
        // And adjust for scrolling if any
        const rect = canvas.getBoundingClientRect(); // Get size and position of canvas relative to viewport
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: Math.round(clientX - rect.left), // X relative to canvas
            y: Math.round(clientY - rect.top)  // Y relative to canvas
        };
    }

    function drawCurrentRect(color = "red") {
        if (!image || !image.src || image.naturalWidth === 0 || image.naturalHeight === 0) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        const rectCanvas = originalToCanvasCoords(
            parseInt(inputX.value) || 0,
            parseInt(inputY.value) || 0,
            parseInt(inputW.value) || 0,
            parseInt(inputH.value) || 0
        );

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(rectCanvas.x, rectCanvas.y, rectCanvas.w, rectCanvas.h);
    }

    [inputX, inputY, inputW, inputH].forEach(input => {
        input.addEventListener('input', () => {
            let val = parseInt(input.value) || 0;
            input.value = Math.max(0, val);

            let currentX = parseInt(inputX.value) || 0;
            let currentY = parseInt(inputY.value) || 0;
            let currentW = parseInt(inputW.value) || 0;
            let currentH = parseInt(inputH.value) || 0;

            if (currentX + currentW > originalWidth) {
                if (input === inputW) input.value = Math.max(0, originalWidth - currentX);
                else if (input === inputX) input.value = Math.max(0, originalWidth - currentW);
            }
            if (currentY + currentH > originalHeight) {
                if (input === inputH) input.value = Math.max(0, originalHeight - currentY);
                else if (input === inputY) input.value = Math.max(0, originalHeight - currentW);
            }

            drawCurrentRect("green");
        });
    });

    canvas.addEventListener('mousedown', e => {
        if (!image || !image.src || image.naturalWidth === 0 || image.naturalHeight === 0) return;
        const pos = getCanvasCoordsFromEvent(e);
        startX_canvas = pos.x;
        startY_canvas = pos.y;
        dragging = true;
    });

    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        const pos = getCanvasCoordsFromEvent(e);

        const currentOriginalX = Math.min(startX_canvas, pos.x);
        const currentOriginalY = Math.min(startY_canvas, pos.y);
        const currentOriginalW = Math.abs(pos.x - startX_canvas);
        const currentOriginalH = Math.abs(pos.y - startY_canvas);

        const originalCoords = canvasToOriginalCoords(currentOriginalX, currentOriginalY);
        const originalDims = canvasToOriginalCoords(currentOriginalW, currentOriginalH);

        inputX.value = Math.max(0, Math.min(originalCoords.x, originalWidth));
        inputY.value = Math.max(0, Math.min(originalCoords.y, originalHeight));
        inputW.value = Math.max(0, Math.min(originalDims.x, originalWidth - (parseInt(inputX.value) || 0)));
        inputH.value = Math.max(0, Math.min(originalDims.y, originalHeight - (parseInt(inputY.value) || 0)));


        drawCurrentRect("red");
    });

    canvas.addEventListener('mouseup', e => {
        dragging = false;
        const pos = getCanvasCoordsFromEvent(e);

        const finalOriginalX_canvas = Math.min(startX_canvas, pos.x);
        const finalOriginalY_canvas = Math.min(startY_canvas, pos.y);
        const finalOriginalW_canvas = Math.abs(pos.x - startX_canvas);
        const finalOriginalH_canvas = Math.abs(pos.y - startY_canvas);

        const originalCoords = canvasToOriginalCoords(finalOriginalX_canvas, finalOriginalY_canvas);
        const originalDims = canvasToOriginalCoords(finalOriginalW_canvas, finalOriginalH_canvas);

        inputX.value = Math.max(0, Math.min(originalCoords.x, originalWidth));
        inputY.value = Math.max(0, Math.min(originalCoords.y, originalHeight));
        inputW.value = Math.max(0, Math.min(originalDims.x, originalWidth - (parseInt(inputX.value) || 0)));
        inputH.value = Math.max(0, Math.min(originalDims.y, originalHeight - (parseInt(inputY.value) || 0)));

        drawCurrentRect("green");
    });

    canvas.addEventListener('touchstart', e => {
        if (!image || !image.src || image.naturalWidth === 0 || image.naturalHeight === 0) return;
        e.preventDefault();
        const pos = getCanvasCoordsFromEvent(e);
        startX_canvas = pos.x;
        startY_canvas = pos.y;
        dragging = true;
    });

    canvas.addEventListener('touchmove', e => {
        if (!dragging) return;
        e.preventDefault();
        const pos = getCanvasCoordsFromEvent(e);

        const currentOriginalX = Math.min(startX_canvas, pos.x);
        const currentOriginalY = Math.min(startY_canvas, pos.y);
        const currentOriginalW = Math.abs(pos.x - startX_canvas);
        const currentOriginalH = Math.abs(pos.y - startY_canvas);

        const originalCoords = canvasToOriginalCoords(currentOriginalX, currentOriginalY);
        const originalDims = canvasToOriginalCoords(currentOriginalW, currentOriginalH);

        inputX.value = Math.max(0, Math.min(originalCoords.x, originalWidth));
        inputY.value = Math.max(0, Math.min(originalCoords.y, originalHeight));
        inputW.value = Math.max(0, Math.min(originalDims.x, originalWidth - (parseInt(inputX.value) || 0)));
        inputH.value = Math.max(0, Math.min(originalDims.y, originalHeight - (parseInt(inputY.value) || 0)));

        drawCurrentRect("red");
    });

    canvas.addEventListener('touchend', e => {
        dragging = false;
        const pos = getCanvasCoordsFromEvent(e.changedTouches[0]);

        const finalOriginalX_canvas = Math.min(startX_canvas, pos.x);
        const finalOriginalY_canvas = Math.min(startY_canvas, pos.y);
        const finalOriginalW_canvas = Math.abs(pos.x - startX_canvas);
        const finalOriginalH_canvas = Math.abs(pos.y - startY_canvas);

        const originalCoords = canvasToOriginalCoords(finalOriginalX_canvas, finalOriginalY_canvas);
        const originalDims = canvasToOriginalCoords(finalOriginalW_canvas, finalOriginalH_canvas);

        inputX.value = Math.max(0, Math.min(originalCoords.x, originalWidth));
        inputY.value = Math.max(0, Math.min(originalCoords.y, originalHeight));
        inputW.value = Math.max(0, Math.min(originalDims.x, originalWidth - (parseInt(inputX.value) || 0)));
        inputH.value = Math.max(0, Math.min(originalDims.y, originalHeight - (parseInt(inputY.value) || 0)));

        drawCurrentRect("green");
    });
    return drawCurrentRect;
}

let drawProfileRect;

// HÃ m set canvas preview luÃ´n full width
function setCanvasFullWidth(canvas, image) {
  const containerWidth = canvas.parentElement.offsetWidth || window.innerWidth;
  const aspectRatio = image.naturalWidth / image.naturalHeight;
  canvas.width = containerWidth;
  canvas.height = containerWidth / aspectRatio;
  canvas.style.width = '100%';
  canvas.style.height = 'auto';
  // Bá» min-h/max-h khi ÄÃ£ cÃ³ áº£nh
  canvas.classList.remove('min-h-32', 'max-h-64', 'bg-gray-100');
}

// Khi chÆ°a cÃ³ áº£nh, giá»¯ min-h/max-h/bg nhÆ° cÅ©
function resetCanvasPlaceholder(canvas, colorClass) {
  canvas.width = 0;
  canvas.height = 0;
  canvas.style.width = '100%';
  canvas.style.height = '';
  canvas.classList.add('min-h-32', 'max-h-64', 'bg-gray-100');
  if (colorClass) {
    canvas.classList.add(colorClass);
  }
}

inputProfileImage.addEventListener('change', async function() {
    if (!this.files.length) {
        profileCtx.clearRect(0, 0, profileCanvas.width, profileCanvas.height);
        currentProfileImageOriginalWidth = 0;
        currentProfileImageOriginalHeight = 0;
        croppedProfileImage = null;
        resetCanvasPlaceholder(profileCanvas, 'border-blue-300');
        return;
    }
    const file = this.files[0];
    const dataURL = await fileToDataURL(file);
    previewImage_profile.src = dataURL;
    previewImage_profile.onload = () => {
        currentProfileImageOriginalWidth = previewImage_profile.naturalWidth;
        currentProfileImageOriginalHeight = previewImage_profile.naturalHeight;
        setCanvasFullWidth(profileCanvas, previewImage_profile);
        if (parseInt(profileCropW.value) === 0 || parseInt(profileCropH.value) === 0 || parseInt(profileCropW.value) > currentProfileImageOriginalWidth || parseInt(profileCropH.value) > currentProfileImageOriginalHeight) {
            profileCropX.value = 0;
            profileCropY.value = 0;
            profileCropW.value = currentProfileImageOriginalWidth;
            profileCropH.value = currentProfileImageOriginalHeight;
        }
        drawProfileRect = setupCanvasInteraction(profileCanvas, profileCtx, previewImage_profile, profileCropX, profileCropY, profileCropW, profileCropH, currentProfileImageOriginalWidth, currentProfileImageOriginalHeight);
        drawProfileRect("green");
    };
    previewImage_profile.onerror = () => {
        alert("KhÃ´ng thá» táº£i áº£nh profile. Vui lÃ²ng kiá»m tra file áº£nh.");
        resetCanvasPlaceholder(profileCanvas, 'border-blue-300');
    };
});

function showLoadingOverlay(show) {
  const overlay = document.getElementById('loadingOverlay');
  if (overlay) {
    if (show) overlay.classList.remove('hidden');
    else overlay.classList.add('hidden');
  }
}
function showLoadingOverlayGhep(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (show) overlay.classList.remove('hidden');
    else overlay.classList.add('hidden');
  }

async function processAndShowCroppedImages() {
    showLoadingOverlay(true);
    try {
        if (!finalOutputCanvas || !finalOutputCtx) {
            alert('Thiáº¿u canvas xuáº¥t áº£nh (finalOutputCanvas). Kiá»m tra láº¡i id trong HTML.');
            showLoadingOverlay(false);
            return;
        }
        finalOutputCanvas.style.display = 'none';
        const downloadBtn = document.getElementById('downloadCombinedImage');
        if (downloadBtn) downloadBtn.style.display = 'none';
        finalOutputCtx.clearRect(0, 0, finalOutputCanvas.width, finalOutputCanvas.height);

        // áº¨n cÃ¡c pháº§n preview cÅ©
        const croppedPreviewSection = document.getElementById('croppedPreviewSection');
        if (croppedPreviewSection) croppedPreviewSection.classList.add('hidden');
        const croppedProfileImg = document.getElementById('croppedProfileImg');
        if (croppedProfileImg) croppedProfileImg.classList.add('hidden');
        if (croppedImagesContainer) {
            croppedImagesContainer.innerHTML = '';
            croppedImagesContainer.style.display = 'none';
        }

        // 1. Crop profile image only
        if (!previewImage_profile.src || previewImage_profile.naturalWidth === 0 || previewImage_profile.naturalHeight === 0) {
            alert('Vui lÃ²ng táº£i áº£nh profile trÆ°á»c khi cáº¯t.');
            showLoadingOverlay(false);
            return;
        }
        croppedProfileImage = await cropProfileImage();
        if (!croppedProfileImage) {
            showLoadingOverlay(false);
            return;
        }
        // Hiá»n thá» áº£nh profile ÄÃ£ cáº¯t
        if (croppedProfileImg) {
            croppedProfileImg.src = croppedProfileImage.src;
            croppedProfileImg.className = 'rounded border-2 border-blue-400 shadow-lg w-28 h-auto mb-1 transition-transform duration-200 hover:scale-105';
            croppedProfileImg.classList.remove('hidden');
        }
        if (croppedPreviewSection) croppedPreviewSection.classList.remove('hidden');
        showLoadingOverlay(false);
    } catch (error) {
        alert('ÄÃ£ xáº£y ra lá»i trong quÃ¡ trÃ¬nh cáº¯t áº£nh. Vui lÃ²ng kiá»m tra láº¡i bá» cá»¥c HTML vÃ  id cÃ¡c pháº§n tá»­.');
        showLoadingOverlay(false);
    }
}

async function cropProfileImage() {
    const x = parseInt(profileCropX.value);
    const y = parseInt(profileCropY.value);
    const w = parseInt(profileCropW.value);
    const h = parseInt(profileCropH.value);

    if (!previewImage_profile.src || w <= 0 || h <= 0 || x + w > previewImage_profile.naturalWidth || y + h > previewImage_profile.naturalHeight) {
        alert('Vui lÃ²ng táº£i vÃ  chá»n vÃ¹ng cáº¯t cho áº£nh profile há»£p lá» (chiá»u rá»ng/cao > 0 vÃ  náº±m trong áº£nh).');
        console.error("Lá»i: ThÃ´ng tin cáº¯t áº£nh profile khÃ´ng há»£p lá».");
        return null;
    }

    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(previewImage_profile, x, y, w, h, 0, 0, w, h);

    const croppedImg = new Image();
    croppedImg.src = canvas.toDataURL("image/png");
    await new Promise(resolve => croppedImg.onload = resolve);
    return croppedImg;
}

// Modified to accept targetWidth and targetHeight for batch images
async function cropBatchImages(files, batchTargetWidth, batchTargetHeight) {
    allCroppedBatchImages = [];
    croppedFilesData = {};

    const x_batch = parseInt(batchCropX.value);
    const y_batch = parseInt(batchCropY.value);
    const w_batch = parseInt(batchCropW.value); // KÃ­ch thÆ°á»c vÃ¹ng cáº¯t trÃªn áº£nh gá»c
    const h_batch = parseInt(batchCropH.value); // KÃ­ch thÆ°á»c vÃ¹ng cáº¯t trÃªn áº£nh gá»c

    if (files.length === 0) {
        alert('KhÃ´ng cÃ³ áº£nh nÃ o ÄÆ°á»£c chá»n Äá» cáº¯t hÃ ng loáº¡t.');
        console.error("Lá»i: KhÃ´ng cÃ³ áº£nh gá»c Äá» cáº¯t hÃ ng loáº¡t.");
        return false;
    }
    if (w_batch <= 0 || h_batch <= 0 || x_batch + w_batch > currentBatchImageOriginalWidth || y_batch + h_batch > currentBatchImageOriginalHeight) {
        alert('Chiá»u rá»ng vÃ  chiá»u cao vÃ¹ng cáº¯t áº£nh hÃ ng loáº¡t pháº£i lá»n hÆ¡n 0 vÃ  náº±m trong áº£nh preview Äáº§u tiÃªn.');
        console.error("Lá»i: KÃ­ch thÆ°á»c vÃ¹ng cáº¯t áº£nh hÃ ng loáº¡t khÃ´ng há»£p lá» hoáº·c náº±m ngoÃ i áº£nh preview.");
        return false;
    }
    if (batchTargetWidth <= 0 || batchTargetHeight <= 0) {
        alert('KÃ­ch thÆ°á»c áº£nh cáº¯t hÃ ng loáº¡t (tá»« áº£nh profile) khÃ´ng há»£p lá». Äáº£m báº£o áº£nh profile cÃ³ kÃ­ch thÆ°á»c há»£p lá».');
        console.error("Lá»i: KÃ­ch thÆ°á»c ÄÃ­ch cho áº£nh hÃ ng loáº¡t khÃ´ng há»£p lá».");
        return false;
    }

    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const img = new Image();
        try {
            const dataURL = await fileToDataURL(file);
            await new Promise((resolve, reject) => {
                img.onload = () => {
                    // Kiá»m tra xem vÃ¹ng cáº¯t cÃ³ náº±m trong áº£nh gá»c hay khÃ´ng
                    if (x_batch + w_batch > img.naturalWidth || y_batch + h_batch > img.naturalHeight) {
                        console.warn(`VÃ¹ng cáº¯t cho áº£nh "${file.name}" náº±m ngoÃ i giá»i háº¡n áº£nh gá»c (${img.naturalWidth}x${img.naturalHeight}). Bá» qua áº£nh nÃ y.`);
                        resolve(); // Bá» qua áº£nh nÃ y vÃ  tiáº¿p tá»¥c vá»i áº£nh tiáº¿p theo
                        return;
                    }

                    const canvas = document.createElement('canvas');
                    // Set canvas dimensions directly to batchTargetWidth and batchTargetHeight
                    canvas.width = batchTargetWidth;
                    canvas.height = batchTargetHeight;
                    const ctx = canvas.getContext('2d');

                    // XÃ³a canvas trÆ°á»c khi váº½ Äá» Äáº£m báº£o ná»n trong suá»t
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Váº½ vÃ¹ng áº£nh ÄÃ£ cáº¯t lÃªn canvas ÄÃ­ch, STRETCHING it to fill the target dimensions
                    // This will ensure no transparent padding inside the cropped batch images
                    ctx.drawImage(img, x_batch, y_batch, w_batch, h_batch, 0, 0, batchTargetWidth, batchTargetHeight);

                    const croppedDataURL = canvas.toDataURL("image/png");
                    const fileName = 'cropped_' + file.name.replace(/\.[^/.]+$/, "") + '.png';

                    croppedFilesData[fileName] = croppedDataURL;

                    const wrap = document.createElement('div');
                    wrap.className = 'cropped-image-wrapper relative flex flex-col items-center opacity-0 transition-opacity duration-300'; // Start with opacity 0
                    wrap.dataset.fileName = fileName;
                    wrap.dataset.originalIndex = i; // Store original index if needed

                    const imgPreview = new Image();
                    imgPreview.src = croppedDataURL;
                    imgPreview.onload = () => {
                        allCroppedBatchImages.push(imgPreview); // Add to ALL cropped images
                        updateZipDownloadLink();

                        // Append, then trigger fade-in and scroll
                        if (croppedImagesContainer) {
                            croppedImagesContainer.appendChild(wrap);
                        }
                        const delay = 50 * (i + 1); // Reduced delay for faster appearance
                        setTimeout(() => {
                            wrap.style.opacity = '1'; // Fade in
                            // Scroll to the newly added image, ensuring it's visible
                            if (wrap) wrap.scrollIntoView({ behavior: 'smooth', block: 'end' });

                            // Hide loading overlay after the last image has appeared and scrolled
                            if (i === files.length - 1) {
                                setTimeout(() => showLoadingOverlay(false), 50); // Add a small buffer after the last scroll
                            }
                        }, delay);
                        resolve();
                    };
                    imgPreview.onerror = () => { resolve(); }
                    imgPreview.className = 'rounded border border-green-300 shadow w-24 h-auto mb-1';
                    wrap.appendChild(imgPreview);
                    // NÃºt X
                    const removeButton = document.createElement('button');
                    removeButton.className = 'absolute -top-2 -right-2 bg-red-100 hover:bg-red-500 text-red-700 hover:text-white border border-red-300 rounded-full w-6 h-6 flex items-center justify-center shadow transition-all duration-200';
                    removeButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>';
                    removeButton.onclick = (e) => {
                        e.stopPropagation();
                        removeCroppedImage(wrap, fileName, imgPreview);
                    };
                    wrap.appendChild(removeButton);
                    // Do not append here, append within setTimeout after onload
                };
                img.onerror = () => { resolve(); };
                img.src = dataURL;
            });
        } catch (error) {
            console.error(`Lá»i xá»­ lÃ½ áº£nh "${file.name}":`, error);
        }
    }
    return true;
}

function removeCroppedImage(element, fileName, imageObjectToRemove) {
    console.log(`Äang xÃ³a áº£nh ÄÃ£ cáº¯t: ${fileName}`);
    if (element) element.remove();
    if (croppedFilesData) delete croppedFilesData[fileName];

    const index = allCroppedBatchImages.indexOf(imageObjectToRemove);
    if (index > -1) {
        allCroppedBatchImages.splice(index, 1);
    }

    console.log(`Tá»ng sá» áº£nh hÃ ng loáº¡t cÃ²n láº¡i sau khi xÃ³a: ${allCroppedBatchImages.length}`);
    updateZipDownloadLink();
}

async function combineImages() {
    if (!croppedProfileImage || croppedProfileImage.naturalWidth === 0 || croppedProfileImage.naturalHeight === 0) {
        alert('Vui lÃ²ng cáº¯t áº£nh profile trÆ°á»c khi ghÃ©p. áº¢nh profile cÃ³ thá» bá» lá»i hoáº·c chÆ°a táº£i.');
        return;
    }
    if (!selectedSkinImages || selectedSkinImages.length === 0) {
        alert('Vui lÃ²ng chá»n Ã­t nháº¥t má»t áº£nh skin Äá» ghÃ©p.');
        return;
    }
    const itemsPerRow = parseInt(document.getElementById('combineCols').value);
    const numRows = parseInt(document.getElementById('combineRows').value);
    if (itemsPerRow < 2 || numRows < 2) {
        alert('Sá» cá»t vÃ  sá» hÃ ng Äá» ghÃ©p pháº£i Ã­t nháº¥t lÃ  2.');
        return;
    }
    showLoadingOverlayGhep(true);
    try {
        finalOutputCanvas.style.display = 'none';
        document.getElementById('downloadCombinedImage').style.display = 'none';
        finalOutputCtx.clearRect(0, 0, finalOutputCanvas.width, finalOutputCtx.height);

        // Load all selected skin images as Image objects
        const skinImageObjs = await Promise.all(selectedSkinImages.map(imgData => {
            return new Promise(resolve => {
                const img = new window.Image();
                img.onload = () => resolve(img);
                img.onerror = () => resolve(null);
                img.src = imgData.url;
            });
        }));
        // Lá»c bá» áº£nh lá»i
        const validSkinImages = skinImageObjs.filter(img => img && img.naturalWidth > 0 && img.naturalHeight > 0);
        if (validSkinImages.length === 0) {
            alert('KhÃ´ng cÃ³ áº£nh skin nÃ o há»£p lá» Äá» ghÃ©p.');
            showLoadingOverlayGhep(false);
            return;
        }
        const profileCroppedWidth = croppedProfileImage.naturalWidth;
        const profileCroppedHeight = croppedProfileImage.naturalHeight;
        const batchImageWidth = Math.floor(profileCroppedWidth / 2);
        const batchImageHeight = Math.floor(profileCroppedHeight / 2);
        await drawCombinedImage(profileCroppedWidth, profileCroppedHeight, batchImageWidth, batchImageHeight, validSkinImages, itemsPerRow, numRows);
        // Show modal
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        modalImg.src = finalOutputCanvas.toDataURL('image/png');
        modal.style.display = 'flex';
        const downloadBtn = document.getElementById('downloadCombinedImage');
        downloadBtn.style.display = 'block';
        downloadBtn.href = finalOutputCanvas.toDataURL('image/png');
        downloadBtn.download = 'combined_image.png';
    } catch (error) {
        console.error('Lá»i trong quÃ¡ trÃ¬nh ghÃ©p áº£nh:', error);
        alert('ÄÃ£ xáº£y ra lá»i trong quÃ¡ trÃ¬nh ghÃ©p áº£nh. Vui lÃ²ng kiá»m tra console Äá» biáº¿t chi tiáº¿t.');
    } finally {
        showLoadingOverlayGhep(false);
    }
}

async function drawCombinedImage(profileOriginalWidth, profileOriginalHeight, batchImageWidth, batchImageHeight, imagesToUse, itemsPerRow, numRows) {
    finalOutputCanvas.style.display = 'none';
    document.getElementById('downloadCombinedImage').style.display = 'none';
    finalOutputCtx.clearRect(0, 0, finalOutputCanvas.width, finalOutputCtx.height);

    // ThÃªm Äoáº¡n nÃ y Äá» Äiá»n mÃ u tráº¯ng cho ná»n cá»§a canvas cuá»i cÃ¹ng
    finalOutputCtx.fillStyle = 'white';
    finalOutputCtx.fillRect(0, 0, finalOutputCanvas.width, finalOutputCanvas.height);

    // Láº¥y giÃ¡ trá» cÃ¡c item
    const gtsValue = parseInt(document.getElementById('gts').value) || 0;
    const gsValue = parseInt(document.getElementById('gs').value) || 0;
    const dtkValue = parseInt(document.getElementById('dtk').value) || 0;
    const tdtValue = document.getElementById('tdt').value.trim(); // Láº¥y text thay vÃ¬ number
    const qhValue = parseInt(document.getElementById('qh').value) || 0;

    // Táº¡o danh sÃ¡ch items cÃ³ giÃ¡ trá» ÄÆ°á»£c nháº­p
    const items = [];
    if (gtsValue > 0) items.push({name: 'Giáº¥y tuyá»t sáº¯c', value: gtsValue, color: '#FF6B6B'});
    if (gsValue > 0) items.push({name: 'Giáº¥y S', value: gsValue, color: '#4ECDC4'});
    if (dtkValue > 0) items.push({name: 'ÄÃ¡ thá»i khÃ´ng', value: dtkValue, color: '#45B7D1'});
    if (tdtValue !== '') items.push({name: 'Tháº» Äá»i tÃªn', value: tdtValue, color: '#FFD93D'}); // Kiá»m tra text khÃ´ng rá»ng
    if (qhValue > 0) items.push({name: 'QuÃ¢n huy', value: qhValue, color: '#6C5CE7'});

    // Táº¡o áº£nh profile má»i vá»i items bar
    let newProfileImage = croppedProfileImage;
    if (items.length > 0) {
        newProfileImage = await createProfileWithItems(croppedProfileImage, items);
    }

    // Calculate canvas dimensions
    const canvasWidth = Math.round(batchImageWidth * itemsPerRow);
    let totalCanvasHeight = 0;

    // Row 1 height (1 hÃ ng áº£nh batch)
    totalCanvasHeight += Math.round(batchImageHeight);
    // Row 2 height (áº£nh profile cao báº±ng 2 áº£nh batch)
    totalCanvasHeight += Math.round(batchImageHeight * 2);
    // Remaining rows height (numRows - 2 hÃ ng áº£nh batch cÃ²n láº¡i)
    if (numRows > 2) {
        totalCanvasHeight += Math.round((numRows - 2) * batchImageHeight);
    }

    finalOutputCanvas.width = canvasWidth;
    finalOutputCanvas.height = totalCanvasHeight;
    // Äáº£m báº£o kÃ­ch thÆ°á»c hiá»n thá» cá»§a canvas khá»p vá»i kÃ­ch thÆ°á»c váº½
    finalOutputCanvas.style.width = `${canvasWidth}px`;
    finalOutputCanvas.style.height = `${totalCanvasHeight}px`;

    let currentX = 0;
    let currentY = 0;
    let imageIndex = 0; // Initialize image counter for imagesToUse array

    // Draw Row 1: Full row of batch images
    for (let col = 0; col < itemsPerRow; col++) {
        if (imageIndex < imagesToUse.length) {
            const batchImage = imagesToUse[imageIndex];
            if (batchImage && batchImage.naturalWidth > 0 && batchImage.naturalHeight > 0) {
                finalOutputCtx.drawImage(batchImage, Math.round(currentX), Math.round(currentY), Math.round(batchImageWidth), Math.round(batchImageHeight));
            } else {
                console.warn(`áº¢nh hÃ ng loáº¡t á» index ${imageIndex} chÆ°a táº£i/lá»i hoáº·c null (hÃ ng 1, cá»t ${col}), bá» qua vÃ  Äá» Ã´ trá»ng.`);
            }
            currentX += batchImageWidth;
            imageIndex++;
        } else {
            break;
        }
    }
    currentY += batchImageHeight; // Move Y position down for next row

    // Draw Row 2: Profile Image + Batch Images (ghepnho)
    const profileDisplayWidth = Math.round(batchImageWidth * 2); // Profile takes 2 columns width
    const profileDisplayHeight = Math.round(batchImageHeight * 2); // Profile takes 2 rows height (of batch images)

    // Draw Profile Image (sá»­ dá»¥ng áº£nh profile má»i)
    if (newProfileImage && newProfileImage.naturalWidth > 0 && newProfileImage.naturalHeight > 0) {
        finalOutputCtx.drawImage(newProfileImage, 0, Math.round(currentY), profileDisplayWidth, profileDisplayHeight);
    } else {
        console.warn("áº¢nh profile khÃ´ng kháº£ dá»¥ng Äá» váº½ vÃ o hÃ ng 2.");
    }

    // Draw batch images in Row 2 (right side - "ghepnho")
    const batchStartX = profileDisplayWidth;
    const batchColsInRow2 = itemsPerRow - 2; // Number of batch images columns in the "ghepnho" section

    // --- Ghepnho - HÃ ng 1 (Upper part of Row 2) ---
    let tempCurrentX = batchStartX;
    for (let col = 0; col < batchColsInRow2; col++) {
        if (imageIndex < imagesToUse.length) {
            const img = imagesToUse[imageIndex];
            if (img && img.naturalWidth > 0 && img.naturalHeight > 0) {
                finalOutputCtx.drawImage(img, Math.round(tempCurrentX), Math.round(currentY), Math.round(batchImageWidth), Math.round(batchImageHeight));
            } else {
                console.warn(`áº¢nh hÃ ng loáº¡t á» index ${imageIndex} chÆ°a táº£i/lá»i hoáº·c null (ghepnho hÃ ng 1, cá»t ${col}), bá» qua.`);
            }
            tempCurrentX += batchImageWidth;
            imageIndex++;
        } else {
            break;
        }
    }

    // --- Ghepnho - HÃ ng 2 (Lower part of Row 2) ---
    tempCurrentX = batchStartX; // Reset X for the second sub-row
    const tempCurrentY_row2_lower = currentY + batchImageHeight; // Y position for the lower part
    for (let col = 0; col < batchColsInRow2; col++) {
        if (imageIndex < imagesToUse.length) {
            const img = imagesToUse[imageIndex];
            if (img && img.naturalWidth > 0 && img.naturalHeight > 0) {
                finalOutputCtx.drawImage(img, Math.round(tempCurrentX), Math.round(tempCurrentY_row2_lower), Math.round(batchImageWidth), Math.round(batchImageHeight));
            } else {
                console.warn(`áº¢nh hÃ ng loáº¡t á» index ${imageIndex} chÆ°a táº£i/lá»i hoáº·c null (ghepnho hÃ ng 2, cá»t ${col}), bá» qua.`);
            }
            tempCurrentX += batchImageWidth;
            imageIndex++;
        } else {
            break;
        }
    }

    currentY += profileDisplayHeight; // Move Y position down (profile height)

    // Draw Remaining Rows: Full rows of Batch Images
    for (let row = 2; row < numRows; row++) { // Start from row 2 (0-indexed) means the third conceptual row
        currentX = 0; // Reset X for each new row
        for (let col = 0; col < itemsPerRow; col++) {
            if (imageIndex < imagesToUse.length) {
                const img = imagesToUse[imageIndex];
                if (img && img.naturalWidth > 0 && img.naturalHeight > 0) {
                    finalOutputCtx.drawImage(img, Math.round(currentX), Math.round(currentY), Math.round(batchImageWidth), Math.round(batchImageHeight));
                } else {
                    console.warn(`áº¢nh hÃ ng loáº¡t á» index ${imageIndex} chÆ°a táº£i/lá»i hoáº·c null (hÃ ng ${row + 1}, cá»t ${col}), bá» qua vÃ  Äá» Ã´ trá»ng.`);
                }
                currentX += batchImageWidth;
                imageIndex++;
            } else {
                break;
            }
        }
        currentY += batchImageHeight;
    }

    // NOTE: ÄÃ¢y lÃ  chá» chá»nh kÃ­ch thÆ°á»c viá»n vÃ ng - thay Äá»i borderWidth á» ÄÃ¢y
    const borderWidth = 10; // â CHá»NH KÃCH THÆ¯á»C VIá»N VÃNG á» ÄÃY
    
    // Váº½ viá»n vÃ ng gold cho áº£nh ghÃ©p cuá»i cÃ¹ng
    finalOutputCtx.strokeStyle = '#FFDF00'; // MÃ u vÃ ng gold
    finalOutputCtx.lineWidth = borderWidth;
    finalOutputCtx.strokeRect(borderWidth/2, borderWidth/2, finalOutputCanvas.width - borderWidth, finalOutputCanvas.height - borderWidth);
    
    finalOutputCanvas.style.display = 'block';
    document.getElementById('downloadCombinedImage').style.display = 'block';
    document.getElementById('downloadCombinedImage').href = finalOutputCanvas.toDataURL("image/png");
    document.getElementById('downloadCombinedImage').download = "combined_image.png";
}

// HÃ m táº¡o áº£nh profile má»i vá»i items bar
async function createProfileWithItems(originalProfileImage, items) {
    console.log('Báº¯t Äáº§u createProfileWithItems vá»i items:', items);
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const profileWidth = originalProfileImage.naturalWidth;
    const profileHeight = originalProfileImage.naturalHeight;
    
    console.log('KÃ­ch thÆ°á»c profile:', profileWidth, 'x', profileHeight);
    
    // Vá» trÃ­ Y cho items bar = cuá»i áº£nh profile - chiá»u cao items bar
    const itemBarHeight = Math.round(profileWidth / 5); // Chiá»u cao = 1/5 chiá»u ngang cá»§a items bar
    
    canvas.width = profileWidth;
    canvas.height = profileHeight; // KhÃ´ng tÄng chiá»u cao ná»¯a, items bar sáº½ overlay
    
    console.log('Canvas size:', canvas.width, 'x', canvas.height);
    console.log('Item bar height:', itemBarHeight);
    
    // Váº½ background tráº¯ng
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Váº½ áº£nh profile gá»c
    ctx.drawImage(originalProfileImage, 0, 0, profileWidth, profileHeight);
    
    // Load áº£nh items
    const itemImages = {};
    const imageNames = {
        'Giáº¥y tuyá»t sáº¯c': 'gts.jpeg',
        'Giáº¥y S': 'gs.jpeg',
        'ÄÃ¡ thá»i khÃ´ng': 'dtk.jpeg',
        'Tháº» Äá»i tÃªn': 'tdt.jpg',
        'QuÃ¢n huy': 'qh.jpeg'
    };
    
    // Load táº¥t cáº£ áº£nh items
    for (const [itemName, imageName] of Object.entries(imageNames)) {
        try {
            const img = new Image();
            img.crossOrigin = 'anonymous'; // ThÃªm crossOrigin Äá» trÃ¡nh lá»i CORS
            img.src = imageName;
            await new Promise((resolve, reject) => {
                img.onload = () => {
                    itemImages[itemName] = img; 
                    resolve();
                };
                img.onerror = () => {
                    console.warn(`KhÃ´ng thá» load áº£nh: ${imageName}`);
                    resolve(); // KhÃ´ng reject, chá» warn
                };
                // Timeout sau 3 giÃ¢y
                setTimeout(() => {
                    console.warn(`Timeout loading áº£nh: ${imageName}`);
                    resolve();
                }, 3000);
            });
        } catch (error) {
            console.warn(`Lá»i load áº£nh ${imageName}:`, error);
        }
    }
    
    // Chá» ghÃ©p nhá»¯ng items cÃ³ giÃ¡ trá» ÄÆ°á»£c nháº­p
    if (items.length > 0) {
        console.log('CÃ³', items.length, 'items Äá» váº½');
        const itemWidth = Math.round(profileWidth / 5); // Chia Äá»u cho 5 Ã´
        
        items.forEach((item, index) => {
            console.log('Váº½ item:', item.name, 'vá»i giÃ¡ trá»:', item.value);
            const itemX = index * itemWidth;
            
            // Vá» trÃ­ Y cho items bar = cuá»i áº£nh profile - chiá»u cao items bar
            const itemBarHeight = Math.round(profileWidth / 5); // Chiá»u cao = 1/5 chiá»u ngang cá»§a items bar
            const itemBarY = profileHeight - itemBarHeight;
            
            console.log('Item position:', itemX, itemBarY);
            
            // Váº½ item nhá» chá» bao trÃ¹m text (khÃ´ng cÃ³ pháº§n trÃªn dÆ°á»i)
            const smallItemSize = itemWidth; // KÃ­ch thÆ°á»c item = 100% chiá»u rá»ng item slot
            const smallItemX = itemX; // Báº¯t Äáº§u tá»« Äáº§u item slot
            const smallItemY = itemBarY; // Báº¯t Äáº§u tá»« Äáº§u item bar
            
            console.log('Small item position:', smallItemX, smallItemY, 'size:', smallItemSize);
            
            // Váº½ áº£nh background cho item nhá» TRÆ¯á»C
            const itemImage = itemImages[item.name];
            console.log('Item image for', item.name, ':', itemImage ? 'loaded' : 'not loaded');
            if (itemImage && itemImage.complete && itemImage.naturalWidth > 0) {
                try {
                    ctx.drawImage(itemImage, smallItemX, smallItemY, smallItemSize, smallItemSize);
                    console.log('ÄÃ£ váº½ áº£nh cho', item.name);
                } catch (error) {
                    console.warn(`Lá»i váº½ áº£nh ${item.name}:`, error);
                    // Fallback: váº½ background mÃ u xÃ¡m nháº¡t
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(smallItemX, smallItemY, smallItemSize, smallItemSize);
                }
            } else {
                // Fallback: váº½ background mÃ u xÃ¡m nháº¡t náº¿u khÃ´ng cÃ³ áº£nh
                console.log('Váº½ fallback cho', item.name);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(smallItemX, smallItemY, smallItemSize, smallItemSize);
            }
            
            // Váº½ sá» lÆ°á»£ng á» gÃ³c dÆ°á»i pháº£i
            const quantitySize = Math.round(itemWidth / 5); // KÃ­ch thÆ°á»c = 1/5 chiá»u ngang item
            const quantityX = itemX + itemWidth - quantitySize - 20; // SÃ¡t bÃªn pháº£i, cÃ¡ch lá» 5px
            const quantityY = itemBarY + itemBarHeight - quantitySize -2; // SÃ¡t dÆ°á»i, cÃ¡ch lá» 5px
            
            // Tá»± Äá»ng Äiá»u chá»nh font size dá»±a trÃªn sá» chá»¯ sá»
            const valueStr = item.value.toString();
            let fontSize = 40; // Font size máº·c Äá»nh
            
            if (valueStr.length == 2) {
                fontSize = 30; // Náº¿u cÃ³ 4+ chá»¯ sá»
            } else if (valueStr.length == 3) {
                fontSize = 30; // Náº¿u cÃ³ 3 chá»¯ sá»
            } else if (valueStr.length == 4) {
              fontSize = 30; // Náº¿u cÃ³ 3 chá»¯ sá»
          }
            
            // Váº½ sá» lÆ°á»£ng á» giá»¯a pháº§n bao bá»c
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = '#FFFFFF'; // MÃ u tráº¯ng
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(valueStr, quantityX + quantitySize/2, quantityY + quantitySize/2);
        });
    }
    
    // Táº¡o áº£nh má»i tá»« canvas
    const newImage = new Image();
    newImage.src = canvas.toDataURL('image/png');
    await new Promise(resolve => newImage.onload = resolve);
    
    return newImage;
}

function updateZipDownloadLink() {
    // KhÃ´ng lÃ m gÃ¬ ná»¯a, vÃ¬ khÃ´ng cÃ²n táº£i zip
    const zipLink = document.getElementById('downloadAll');
    if (zipLink) zipLink.style.display = 'none';
}

function fileToDataURL(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

// HÃ m hiá»n thá» áº£nh cáº¯t ra trong popup
function showImageInModal(imageSrc) {
  const modal = document.getElementById('imageModal');
  const modalImg = document.getElementById('modalImage');
  modalImg.src = imageSrc;
  modal.style.display = 'flex'; // Use flex to show the modal and apply centering styles
}

// ÄÃ³ng modal khi báº¥m nÃºt close hoáº·c click ra ngoÃ i
function setupModalEvents() {
  const modal = document.getElementById('imageModal');
  const closeBtn = document.getElementById('closeModalBtn');
  const modalImg = document.getElementById('modalImage');

  if (closeBtn) {
    closeBtn.onclick = () => {
      modal.style.display = 'none';
      if (modalImg) modalImg.src = '';
    };
  }

  if (modal) {
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.style.display = 'none';
        if (modalImg) modalImg.src = '';
      }
    };
  }
}

// --- HÆ¯á»NG DáºªN Sá»¬ Dá»¤NG MODAL ---
document.addEventListener('DOMContentLoaded', () => {
    setupModalEvents(); // Gáº¯n sá»± kiá»n cho modal popup ngay khi DOM sáºµn sÃ ng
    setupGuideModalEvents();
    showGuideModalOnFirstLoad();
    // ÄÃ£ bá» Äoáº¡n gÃ¡n sá»± kiá»n ÄÃ³ng popup hÆ°á»ng dáº«n sá»­ dá»¥ng á» ÄÃ¢y Äá» trÃ¡nh trÃ¹ng láº·p
});

function setupGuideModalEvents() {
  const guideModal = document.getElementById('guideModal');
  const closeGuideBtn = document.getElementById('closeGuideBtn');
  const openGuideBtn = document.getElementById('openGuideBtn');

  if (closeGuideBtn) {
    closeGuideBtn.onclick = () => {
      guideModal.classList.add('hidden');
    };
  }
  if (openGuideBtn) {
    openGuideBtn.onclick = () => {
      guideModal.classList.remove('hidden');
    };
  }
  // KhÃ´ng cho phÃ©p ÄÃ³ng báº±ng click ra ngoÃ i hoáº·c phÃ­m ESC
  if (guideModal) {
    guideModal.onclick = (e) => {
      if (e.target === guideModal) {
        // KhÃ´ng lÃ m gÃ¬ cáº£
      }
    };
  }
  document.addEventListener('keydown', function(e) {
    if (guideModal.style.display !== 'none' && (e.key === 'Escape' || e.key === 'Esc')) {
      e.preventDefault();
    }
  });
}

function showGuideModalOnFirstLoad() {
  const guideModal = document.getElementById('guideModal');
  if (guideModal) {
    guideModal.classList.remove('hidden');
  }
}

// --- SKIN LIBRARY POPUP LOGIC ---
import skinImageList from './imgData.js';

let selectedSkinImages = [];

function renderSkinLibraryGrid(filter = '') {
  const grid = document.getElementById('skinLibraryGrid');
  grid.innerHTML = '';
  const filterLower = filter.trim().toLowerCase();
  const filteredList = skinImageList.filter(img => img.name.toLowerCase().includes(filterLower));
  filteredList.forEach((img, idx) => {
    const wrap = document.createElement('div');
    wrap.className = 'relative flex flex-col items-center border rounded p-1 cursor-pointer group transition-all duration-200 hover:shadow-lg hover:scale-105';
    wrap.dataset.url = img.url;
    wrap.dataset.name = img.name;
    // áº¢nh lazy load
    const image = document.createElement('img');
    image.className = 'lazy rounded shadow border w-24 h-30 object-top mb-1 transition-transform duration-200';
    image.setAttribute('data-src', img.url);
    image.setAttribute('alt', img.name);
    // Check ÄÃ£ chá»n
    const selectedIdx = selectedSkinImages.findIndex(sel => sel.url === img.url);
    const isSelected = selectedIdx > -1;
    if (isSelected) {
      wrap.classList.add('ring-4', 'ring-blue-500', 'bg-blue-50');
    }
    // TÃªn áº£nh
    const label = document.createElement('span');
    label.className = 'text-xs text-center truncate w-full';
    label.textContent = img.name;
    // Overlay tick khi chá»n
    const overlay = document.createElement('div');
    overlay.className = 'absolute inset-0 flex items-center justify-center pointer-events-none';
    overlay.innerHTML = isSelected ? '<span class="block text-3xl text-blue-600 font-bold drop-shadow">âï¸</span>' : '';
    wrap.appendChild(image);
    wrap.appendChild(label);
    wrap.appendChild(overlay);
    // Badge sá» thá»© tá»± náº¿u ÄÃ£ chá»n
    let orderBadge = null;
    if (isSelected) {
      orderBadge = document.createElement('div');
      orderBadge.className = 'absolute top-1 left-1 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center shadow';
      orderBadge.textContent = (selectedIdx + 1).toString();
      wrap.appendChild(orderBadge);
    }
    // Click chá»n/bá» chá»n (khÃ´ng render láº¡i toÃ n grid)
    wrap.onclick = () => {
      const idx = selectedSkinImages.findIndex(sel => sel.url === img.url);
      if (idx > -1) {
        selectedSkinImages.splice(idx, 1);
        wrap.classList.remove('ring-4', 'ring-blue-500', 'bg-blue-50');
        overlay.innerHTML = '';
        if (orderBadge) orderBadge.remove();
        // Cáº­p nháº­t láº¡i badge sá» thá»© tá»± cho cÃ¡c áº£nh cÃ²n láº¡i trong grid
        updateSkinOrderBadgesInGrid();
      } else {
        selectedSkinImages.push(img);
        wrap.classList.add('ring-4', 'ring-blue-500', 'bg-blue-50');
        overlay.innerHTML = '<span class="block text-3xl text-blue-600 font-bold drop-shadow">âï¸</span>';
        // ThÃªm badge sá» thá»© tá»±
        const badge = document.createElement('div');
        badge.className = 'absolute top-1 left-1 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center shadow';
        badge.textContent = selectedSkinImages.length.toString();
        wrap.appendChild(badge);
        // Cáº­p nháº­t láº¡i badge sá» thá»© tá»± cho cÃ¡c áº£nh cÃ²n láº¡i trong grid
        updateSkinOrderBadgesInGrid();
      }
      updateSelectedSkinCount();
      updateConfirmSkinBtnState();
    };
    grid.appendChild(wrap);
  });
  // Khá»i táº¡o láº¡i lazyload
  if (window.LazyLoad) new window.LazyLoad({ elements_selector: '.lazy' });
  // Hiá»n thá» sá» lÆ°á»£ng skin ÄÃ£ chá»n á» gÃ³c popup
  updateSelectedSkinCount();
}

// HÃ m cáº­p nháº­t láº¡i badge sá» thá»© tá»± cho cÃ¡c áº£nh ÄÃ£ chá»n trong grid mÃ  khÃ´ng render láº¡i toÃ n bá» grid
function updateSkinOrderBadgesInGrid() {
  const grid = document.getElementById('skinLibraryGrid');
  if (!grid) return;
  // Duyá»t qua táº¥t cáº£ cÃ¡c pháº§n tá»­ con cá»§a grid
  Array.from(grid.children).forEach(wrap => {
    const url = wrap.dataset.url;
    const idx = selectedSkinImages.findIndex(sel => sel.url === url);
    let badge = wrap.querySelector('.absolute.top-1.left-1.bg-blue-600');
    if (idx > -1) {
      if (!badge) {
        badge = document.createElement('div');
        badge.className = 'absolute top-1 left-1 bg-blue-600 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center shadow';
        wrap.appendChild(badge);
      }
      badge.textContent = (idx + 1).toString();
      wrap.classList.add('ring-4', 'ring-blue-500', 'bg-blue-50');
    } else {
      if (badge) badge.remove();
      wrap.classList.remove('ring-4', 'ring-blue-500', 'bg-blue-50');
    }
  });
}

function updateSelectedSkinCount() {
  // Hiá»n thá» sá» lÆ°á»£ng skin ÄÃ£ chá»n á» gÃ³c popup
  const countEl = document.getElementById('selectedSkinCount');
  if (countEl) countEl.textContent = selectedSkinImages.length;
  // Náº¿u cÃ³ popup, hiá»n thá» sá» lÆ°á»£ng á» gÃ³c pháº£i trÃªn, Äáº£m báº£o náº±m trong popup
  const popup = document.getElementById('skinLibraryModal');
  if (popup) {
    let badge = popup.querySelector('.selected-skin-count-badge');
    if (!badge) {
      badge = document.createElement('div');
      badge.className = 'selected-skin-count-badge fixed md:absolute top-4 right-6 md:top-2 md:right-4 bg-blue-600 text-white text-xs font-bold rounded-full w-8 h-8 flex items-center justify-center shadow z-50';
      // Äáº£m báº£o badge lÃ  con trá»±c tiáº¿p cá»§a popup Äá» khÃ´ng bá» lá»ch ra ngoÃ i
      popup.appendChild(badge);
    }
    badge.textContent = selectedSkinImages.length;
    badge.style.display = selectedSkinImages.length > 0 ? 'flex' : 'none';
  }
}
function updateConfirmSkinBtnState() {
  const btn = document.getElementById('confirmSkinSelectionBtn');
  if (btn) btn.disabled = selectedSkinImages.length === 0;
}

// Má» popup
const openSkinLibraryBtn = document.getElementById('openSkinLibraryBtn');
const skinLibraryModal = document.getElementById('skinLibraryModal');
const closeSkinLibraryBtn = document.getElementById('closeSkinLibraryBtn');
const skinLibrarySearch = document.getElementById('skinLibrarySearch');
const confirmSkinSelectionBtn = document.getElementById('confirmSkinSelectionBtn');

if (openSkinLibraryBtn && skinLibraryModal) {
  openSkinLibraryBtn.onclick = () => {
    skinLibraryModal.classList.remove('hidden');
    renderSkinLibraryGrid();
    skinLibrarySearch.value = '';
    updateConfirmSkinBtnState();
  };
}
if (closeSkinLibraryBtn && skinLibraryModal) {
  closeSkinLibraryBtn.onclick = () => {
    skinLibraryModal.classList.add('hidden');
  };
}
// Debounce cho tÃ¬m kiáº¿m skin
let skinSearchDebounceTimeout = null;
if (skinLibrarySearch) {
  skinLibrarySearch.oninput = (e) => {
    if (skinSearchDebounceTimeout) clearTimeout(skinSearchDebounceTimeout);
    skinSearchDebounceTimeout = setTimeout(() => {
      renderSkinLibraryGrid(e.target.value);
      updateConfirmSkinBtnState();
    }, 400);
  };
}
// --- HIá»N THá» DANH SÃCH áº¢NH SKIN ÄÃ CHá»N Vá»I HIá»U á»¨NG ---
function renderSelectedSkinPreviewAnimated() {
  const containerId = 'selectedSkinPreviewContainer';
  let container = document.getElementById(containerId);
  if (!container) {
    const parent = document.getElementById('openSkinLibraryBtn').parentElement;
    container = document.createElement('div');
    container.id = containerId;
    container.className = 'flex flex-wrap gap-2 mt-2';
    parent.appendChild(container);
  }
  container.innerHTML = '';
  container.style.display = selectedSkinImages.length > 0 ? 'flex' : 'none';
  // Hiá»u á»©ng xuáº¥t hiá»n láº§n lÆ°á»£t tá»«ng áº£nh
  selectedSkinImages.forEach((img, idx) => {
    setTimeout(() => {
      const wrap = document.createElement('div');
      wrap.className = 'relative flex flex-col items-center border rounded p-1 bg-white shadow opacity-0 transition-opacity duration-300';
      // áº¢nh
      const image = document.createElement('img');
      image.src = img.url;
      image.alt = img.name;
      image.className = 'w-16 h-16 object-top rounded';
      // TÃªn áº£nh
      const label = document.createElement('span');
      label.className = 'text-xs text-center truncate w-16';
      label.textContent = img.name;
      // NÃºt X
      const removeBtn = document.createElement('button');
      removeBtn.className = 'absolute -top-2 -right-2 bg-red-100 hover:bg-red-500 text-red-700 hover:text-white border border-red-300 rounded-full w-5 h-5 flex items-center justify-center shadow';
      removeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>';
      removeBtn.onclick = (e) => {
        e.stopPropagation();
        // XÃ³a khá»i selectedSkinImages
        const removeIdx = selectedSkinImages.findIndex(sel => sel.url === img.url);
        if (removeIdx > -1) selectedSkinImages.splice(removeIdx, 1);
        // XÃ³a node DOM nÃ y khá»i container, khÃ´ng render láº¡i toÃ n bá»
        wrap.remove();
        updateSelectedSkinCount();
        updateConfirmSkinBtnState();
        // KhÃ´ng gá»i láº¡i renderSelectedSkinPreviewAnimated()
      };
      wrap.appendChild(image);
      wrap.appendChild(label);
      wrap.appendChild(removeBtn);
      container.appendChild(wrap);
      setTimeout(() => { wrap.style.opacity = '1'; }, 10);
    }, idx * 100);
  });
}
// Sá»­a sá»± kiá»n xÃ¡c nháº­n chá»n skin Äá» render preview cÃ³ hiá»u á»©ng
if (typeof confirmSkinSelectionBtn !== 'undefined' && confirmSkinSelectionBtn && skinLibraryModal) {
  confirmSkinSelectionBtn.onclick = () => {
    skinLibraryModal.classList.add('hidden');
    updateSelectedSkinCount();
    updateConfirmSkinBtnState();
    renderSelectedSkinPreviewAnimated();
  };
}
window.processAndShowCroppedImages = processAndShowCroppedImages;
window.combineImages = combineImages;

// Thay Äá»i sá»± kiá»n nÃºt GhÃ©p áº¢nh (BÆ°á»c 5)
const combineBtn = document.querySelector('button[onclick="combineImages()"]');
if (combineBtn) {
  combineBtn.onclick = showCombineDemoModal;
}

// HÃ m má» popup demo kÃ©o tháº£
function showCombineDemoModal() {
  // áº¨n modal áº£nh ghÃ©p náº¿u Äang má»
  const imageModal = document.getElementById('imageModal');
  if (imageModal) imageModal.style.display = 'none';
  // Hiá»n popup demo
  const demoModal = document.getElementById('combineDemoModal');
  if (demoModal) demoModal.classList.remove('hidden');
  renderCombineDemoGrid();
}

// ÄÃ³ng popup demo
const closeCombineDemoBtn = document.getElementById('closeCombineDemoBtn');
if (closeCombineDemoBtn) {
  closeCombineDemoBtn.onclick = () => {
    const demoModal = document.getElementById('combineDemoModal');
    if (demoModal) demoModal.classList.add('hidden');
  };
}

// XÃ¡c nháº­n ghÃ©p áº£nh tháº­t
const confirmCombineBtn = document.getElementById('confirmCombineBtn');
if (confirmCombineBtn) {
  confirmCombineBtn.onclick = () => {
    const demoModal = document.getElementById('combineDemoModal');
    if (demoModal) demoModal.classList.add('hidden');
    combineImages();
  };
}

// Render grid demo kÃ©o tháº£ vá»i bá» cá»¥c giá»ng áº£nh ghÃ©p tháº­t (profile + skin)
async function renderCombineDemoGrid() {
  const grid = document.getElementById('combineDemoGrid');
  if (!grid) return;
  grid.innerHTML = '';
  
  // Láº¥y giÃ¡ trá» cÃ¡c item
  const gtsValue = parseInt(document.getElementById('gts').value) || 0;
  const gsValue = parseInt(document.getElementById('gs').value) || 0;
  const dtkValue = parseInt(document.getElementById('dtk').value) || 0;
  const tdtValue = parseInt(document.getElementById('tdt').value) || 0;
  const qhValue = parseInt(document.getElementById('qh').value) || 0;

  // Táº¡o danh sÃ¡ch items cÃ³ giÃ¡ trá» ÄÆ°á»£c nháº­p
  const items = [];
  if (gtsValue > 0) items.push({name: 'Giáº¥y tuyá»t sáº¯c', value: gtsValue, color: '#FF6B6B'});
  if (gsValue > 0) items.push({name: 'Giáº¥y S', value: gsValue, color: '#4ECDC4'});
  if (dtkValue > 0) items.push({name: 'ÄÃ¡ thá»i khÃ´ng', value: dtkValue, color: '#45B7D1'});
  if (tdtValue >0) items.push({name: 'Tháº» Äá»i tÃªn', value: tdtValue, color: '#FFD93D'}); // Kiá»m tra text khÃ´ng rá»ng
  if (qhValue > 0) items.push({name: 'QuÃ¢n huy', value: qhValue, color: '#6C5CE7'});

  // Táº¡o áº£nh profile má»i vá»i items bar
  let newProfileImage = croppedProfileImage;
  if (items.length > 0 && croppedProfileImage) {
    newProfileImage = await createProfileWithItems(croppedProfileImage, items);
  }

  // Láº¥y sá» cá»t/hÃ ng
  const cols = parseInt(document.getElementById('combineCols').value) || 4;
  const rows = parseInt(document.getElementById('combineRows').value) || 4;
  const totalRows = rows + 1; // Tá»ng sá» hÃ ng = combineRows + 1
  
  // TÃ­nh toÃ¡n sá» lÆ°á»£ng áº£nh skin cáº§n cho layout
  // HÃ ng 1: cols áº£nh skin
  // HÃ ng 2: 2x2 profile + (cols-2)*2 áº£nh skin
  // HÃ ng 3+: cols* (totalRows-2) áº£nh skin
  const skinSlots = [];
  // HÃ ng 1
  for (let i = 0; i < cols; i++) skinSlots.push({row: 1, col: i+1});
  // HÃ ng 2 (bá» 2 Ã´ Äáº§u cho profile)
  for (let i = 2; i < cols; i++) skinSlots.push({row: 2, col: i+1});
  // HÃ ng 3 (bá» 2 Ã´ Äáº§u cho profile)
  for (let i = 2; i < cols; i++) skinSlots.push({row: 3, col: i+1});
  // HÃ ng 4+ (full hÃ ng)
  for (let r = 4; r <= totalRows; r++) for (let c = 1; c <= cols; c++) skinSlots.push({row: r, col: c});
  
  // Láº¥y ÄÃºng sá» áº£nh skin sáº½ dÃ¹ng
  const demoImages = selectedSkinImages.slice(0, skinSlots.length);
  
  // TÃ­nh toÃ¡n kÃ­ch thÆ°á»c áº£nh Äá» vá»«a vá»i popup
  const popupContainer = document.getElementById('combineDemoModal');
  const popupWidth = popupContainer ? popupContainer.offsetWidth * 0.8 : 800; // 80% chiá»u rá»ng popup
  const popupHeight = popupContainer ? popupContainer.offsetHeight * 0.7 : 600; // 70% chiá»u cao popup
  const gap = 12; // Khoáº£ng cÃ¡ch giá»¯a cÃ¡c áº£nh
  
  // TÃ­nh toÃ¡n kÃ­ch thÆ°á»c áº£nh tá»i Äa cÃ³ thá»
  const maxImageWidth = (popupWidth - (cols + 1) * gap) / cols;
  const maxImageHeight = (popupHeight - (totalRows + 1) * gap) / totalRows;
  
  // Chá»n kÃ­ch thÆ°á»c nhá» hÆ¡n Äá» Äáº£m báº£o vá»«a cáº£ chiá»u rá»ng vÃ  chiá»u cao
  const imageSize = Math.min(maxImageWidth, maxImageHeight, 100); // Giá»i háº¡n tá»i Äa 100px
  
  console.log('Grid size calculation:', {
    cols, totalRows, popupWidth, popupHeight,
    maxImageWidth, maxImageHeight, imageSize
  });
  
  // Táº¡o grid container
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = `repeat(${cols}, ${imageSize}px)`;
  grid.style.gridTemplateRows = `repeat(${totalRows}, ${imageSize}px)`;
  grid.style.gap = `${gap}px`;
  grid.style.justifyContent = 'center';
  grid.style.alignItems = 'center';
  
  // Render profile (chiáº¿m 2x2) - sá»­ dá»¥ng áº£nh profile má»i
  const profileImg = document.createElement('img');
  if (newProfileImage && newProfileImage.src) {
    profileImg.src = newProfileImage.src;
  } else if (croppedProfileImage && croppedProfileImage.src) {
    profileImg.src = croppedProfileImage.src;
  } else {
    profileImg.src = 'profile.png'; // fallback
  }
  profileImg.className = 'object-cover rounded border shadow bg-white';
  profileImg.style.width = '100%';
  profileImg.style.height = '100%';
  profileImg.style.objectFit = 'contain';
  profileImg.style.gridRow = '2 / span 2';
  profileImg.style.gridColumn = '1 / span 2';
  profileImg.draggable = false;
  grid.appendChild(profileImg);
  
  // Render cÃ¡c áº£nh skin vÃ o ÄÃºng slot
  demoImages.forEach((img, idx) => {
    const slot = skinSlots[idx];
    const imgEl = document.createElement('img');
    imgEl.src = img.url;
    imgEl.className = 'object-cover rounded border shadow bg-white cursor-move';
    imgEl.style.width = '100%';
    imgEl.style.height = '100%';
    imgEl.style.objectFit = 'contain';
    imgEl.style.gridRow = slot.row;
    imgEl.style.gridColumn = slot.col;
    imgEl.draggable = true;
    imgEl.dataset.idx = idx;
    
    // Drag events
    imgEl.ondragstart = (e) => {
      e.dataTransfer.setData('text/plain', idx);
      imgEl.classList.add('opacity-50');
    };
    imgEl.ondragend = () => {
      imgEl.classList.remove('opacity-50');
    };
    imgEl.ondragover = (e) => e.preventDefault();
    imgEl.ondrop = (e) => {
      e.preventDefault();
      const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
      const toIdx = parseInt(imgEl.dataset.idx);
      if (fromIdx !== toIdx) {
        // HoÃ¡n Äá»i vá» trÃ­ trong demoImages
        [demoImages[fromIdx], demoImages[toIdx]] = [demoImages[toIdx], demoImages[fromIdx]];
        // Äá»ng bá» láº¡i selectedSkinImages theo demoImages
        for (let i = 0; i < demoImages.length; i++) {
          const idxInAll = selectedSkinImages.findIndex(s => s.url === demoImages[i].url);
          if (idxInAll !== i) {
            [selectedSkinImages[i], selectedSkinImages[idxInAll]] = [selectedSkinImages[idxInAll], selectedSkinImages[i]];
          }
        }
        renderCombineDemoGrid();
      }
    };
    grid.appendChild(imgEl);
  });
}